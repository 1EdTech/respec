<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset='utf-8'>
  <!-- <script src='https://purl.imsglobal.org/spec/respec-ims-default.js' async class='remove'></script> -->
  <script src='../js/deps/require.js' data-main='../js/profile-ims-default' async class='remove'></script>
  <script class='remove'>
    var respecConfig = {
      specTitle: "IMS Security Framework",
      shortName: "security",
      specStatus: "IMS Final Release",
      specDate: "July 25th, 2018",
      specVersion: "1.0",
      specNature: "normative",
      specType: "spec",
      overrideCSSLocation: "ims-base.css",
      contributors: [{
          name: "Andrew Cunningham",
          company: "Google"
        },
        {
          name: "Paul Gray",
          company: "Learning Objects"
        },
        {
          name: "Viktor Haag",
          company: "D2L"
        },
        {
          name: "Dereck Haskins",
          company: "IMS Global"
        },
        {
          name: "Martin Lenord",
          company: "Turnitin"
        },
        {
          name: "Mark Leuba",
          company: "IMS Global"
        },
        {
          name: "Karl Lloyd",
          company: "Instructure"
        },
        {
          name: "John McGettrick",
          company: "Turnitin"
        },
        {
          name: "Mark McKell",
          company: "IMS Global",
          role: "editor"
        },
        {
          name: "Alex Medcalf-Bell",
          company: "Turnitin"
        },
        {
          name: "Nathan Mills",
          company: "Instructure",
          role: "editor"
        },
        {
          name: "Bracken Mosbacker",
          company: "Turnitin"
        },
        {
          name: "Marc Phillips",
          company: "Instructure"
        },
        {
          name: "Eric Preston",
          company: "Blackboard"
        },
        {
          name: "James Rissler",
          company: "IMS Global"
        },
        {
          name: "Charles Severance",
          company: "University of Michigan"
        },
        {
          name: "Lior Shorshi",
          company: "McGraw-Hill Education"
        },
        {
          name: "Colin Smythe",
          company: "IMS Global",
          role: "editor"
        },
        {
          name: "Claude Vervoort",
          company: "Cengage",
          role: "editor"
        },
        {
          name: "Jim Walkoski",
          company: "D2L"
        }
      ],
      localBiblio: {
        "ISO29115": {
          title: "Information technology - Security techniques - Entity authentication assurance framework",
          href: "https://www.iso.org/standard/45138.html"
        },
        "ITU-X1252": {
          title: "X.1252: Baseline identity management terms and definitions",
          date: "2010",
          href: "https://www.itu.int/rec/T-REC-X.1252-201004-I"
        },
        "OPENID-CCORE": {
          title: "OpenID Connect Core 1.0",
          date: "Nov 8 2014",
          href: "http://openid.net/specs/openid-connect-core-1_0.html"
        },
        "OAUTH2-FPRM": {
          title: "OAuth 2.0 Form Post Response Mode",
          date: "April 27, 2015",
          href: "http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html"
        }
      }
    };
  </script>
  <style>
    table#version-table td {
      padding: 0.2em
    }
  </style>
</head>

<body>
  <section class="introductory" id="abstract">
    <h2>Abstract</h2>
  	<p>IMS Global has created, is creating, and will create, service-oriented and/or
  		message-exchange interoperability specifications. These service-based specifications
  		recommend or require a number of different security patterns: for example,
  		the use of OAuth 1.0 based message signing, OAuth 2 based authentication and
  		authorization, and so forth. In this document, IMS defines a set of patterns
  		for security that all of its specifications SHOULD use (only in special circumstances
  		will IMS consider exceptions). These security patterns are based upon the appropriate
  		standards and specifications published by other organizations, for example
  		the Internet Engineering Task Force (IETF) and its Requests For Comments (RFCs).
  	</p>
  	<p>All new IMS specifications SHOULD use the security patterns defined herein. IMS
  		MAY revise specifications that have already been published to align with these
  		security patterns.</p>
  </section>

  <section>
    <h2>Introduction</h2>
    <section>
      <h3> Scope and Context</h3>
      <p>Adopters of IMS specifications will refer to this document with respect to
        the security approaches they MUST use. IMS' aim is that all its specifications
        use a common IMS security framework. Use of a common security framework promotes
        a consistent and compatible implementation requirement that simplifies adoption
        when more than one IMS specification is being implemented.</p>
      <p>All IMS service-based specifications SHOULD make reference to this document.
        The relevant IMS service specifications will cite appropriate sections of
        this document. In some cases, IMS specifications may contain exceptions to
        the recommendations made in this document. These exceptions MUST be explained
        and justified in the IMS specification citing this document. The Best Practice
        and/or Implementation Guide documents for the relevant IMS specification
        SHOULD provide further explanation to implementers regarding the manner in
        which they are to implement security requirements in the context of that
        specification.
      </p>
    </section>

    <section>
      <h3>Terminology</h3>

      <p>This specification defines the following terms:</p>
      <dl>
        <dt><dfn>Authentication</dfn></dt>
        <dd>Process used to achieve sufficient confidence in the binding between an entity
          and the presented <a>Identity</a>.</dd>

        <dt><dfn data-lt="Claim|Claims">Claim</dfn></dt>
        <dd>Piece of information asserted about an entity.</dd>

        <dt><dfn data-lt="Consumer|Consumers|Consumer's">Consumer</dfn></dt>
        <dd>An entity for which an end user gains access through a <em><a>Platform</a></em>.
          The Consumer may make use of, or provide services to, the Platform.</dd>

        <dt><dfn>ID Token</dfn></dt>
        <dd>JWT that contains <em><a>Claims</a></em> about the
          <em>Authentication</em> event. It MAY contain other Claims.</dd>

        <dt><dfn data-lt="Identifier|Identifiers">Identifier</dfn></dt>
        <dd>Value that uniquely characterizes an entity in a specific context.</dd>

        <dt><dfn>Identity</dfn></dt>
        <dd>Set of attributes related to an entity.</dd>

        <dt><dfn>Issuer</dfn></dt>
        <dd>Entity that issues a set of <em><a>Claims</a></em>. The Issuer is the entity
          that starts an information exchange and as such could be either a Platform
          or a <a>Consumer</a>.</dd>

        <dt><dfn>Issuer Identifier</dfn></dt>
        <dd>Verifiable identifier for an <em><a>Issuer</a></em>. An Issuer Identifier
          is a case-sensitive URL, using the HTTPS scheme, that contains scheme,
          host, and optionally, port number, and path components, and no query or
          fragment components.
        </dd>

        <dt><dfn data-lt="Message|Messages">Message</dfn></dt>
      	<dd>Request or a response between a <em><a>Consumer</a></em> and a <em><a>Platform</a></em>.</dd>

        <dt><dfn data-lt="Platform|Platforms|Platform's">Platform</dfn></dt>
        <dd>An entity through which an end user interacts to gain access to some remotely
        	launched <em><a>Tool</a></em> or a <em><a>Consumer</a></em>. The Platform may make use of, or provide
          services to, the Tool or may provide services to the Consumer.</dd>

        <dt><dfn>Private Key</dfn></dt>
        <dd>The private key in the private-public key pair. This is the secret key that
          is used by the <a>Issuer</a>, of a message, to sign the JWT using the JSON
          Web Signature [[!RFC7515]].</dd>

        <dt><dfn>Public Key</dfn></dt>
        <dd>The public key in the private-public key pair. This is the key used at the
          receiving system to authenticate the message and confirm it has not been
          altered during transmission.</dd>

        <dt><dfn>Subject Identifier</dfn></dt>
        <dd>Locally unique and never-reassigned identifier within the
          <em><a>Issuer</a></em> for the end user, which is intended to be consumed
          by the <em><a>Consumer</a></em>. This identifier MUST be the same as the
          Issuer's User ID for that end user.</dd>

      	<dt><dfn data-lt="Tool|Tools|Tool's">Tool</dfn></dt>
      	<dd>An entity which has been launched by a <em><a>Platform</a></em>. The Tool may make use of, or provide
      		services to, the Platform.</dd>

        <dt><dfn data-lt="Validation|Validate">Validation</dfn></dt>
        <dd>Process intended to establish the soundness or correctness of a construct.</dd>

        <dt><dfn>Verification</dfn></dt>
        <dd>Process intended to test or prove the truth or accuracy of a fact or value.</dd>

        <dt><dfn>Voluntary Claim</dfn></dt>
        <dd><em><a>Claim</a></em> specified by the <em><a>Consumer</a></em> as being useful
          but not essential for the specific task requested by the end user.</dd>
      </dl>

      <p>This specification also uses the terms:</p>
      <dl>
        <dt>"Client", "Client Authentication", "Client Identifier" and "Scope"</dt>
        <dd>As defined by OAuth 2.0 [[!RFC6749]].</dd>

        <dt>"Claim List", "Claim Name", "Claim Value", "JSON Web Token (JWT)", "JWT
            Claims Set", "Nested JWT", and "StringOrURI"</dt>
        <dd>As defined by JSON Web Token [[!RFC7519]]</dd>

        <dt>"Header Parameter" and "JOSE Header"</dt>
        <dd>As defined by JSON Web Signature (JWS)[[!RFC7515]]</dd>

        <dt>"User Agent"</dt>
        <dd>As defined by [[!RFC2616]].</dd>
      </dl>

      <p>The terminology definitions in this section, are a normative portion of this
        specification, imposing requirements upon implementations. All the capitalized
        words in the text of this specification, such as "Issuer Identifier", refer
        to these defined terms. Whenever readers encounter them, they must follow
        their definitions found in this section.</p>

      <p>Note that that the term "Client"is used as defined by OAuth 2.0. Therefore,
      	communication being secured is between a Platform and a Consumer. Depending on
      	the specific exchange choreography either of these could be the Client. From the
      	perspective of a service either the Platform or the Consumer could initiate the
      	communication exchange.</p>

      <p>For more background on some of the terminology used, see Internet Security
        Glossary, Version 2 [[!RFC4949]], ISO/IEC 29115 Entity Authentication Assurance
        [[!ISO29115]], and ITU-T X.1252 [[!ITU-X1252]].</p>

    </section>

    <section>
      <h3>Acronyms</h3>
      <dl>
        <dt>HTTP</dt>
        <dd>Hypertext Transport Protocol</dd>
        <dt>IANA</dt>
        <dd>Internet Assigned Number Authority</dd>
        <dt>IETF</dt>
        <dd>Internet Engineering Task Force</dd>
        <dt>ISO</dt>
        <dd>International Standards Organization</dd>
        <dt>ITU</dt>
        <dd>International Telecommunications Union</dd>
        <dt>JOSE</dt>
        <dd>JSON Object Signing and Encryption</dd>
        <dt>JSON</dt>
        <dd>Java Script Object Notation</dd>
        <dt>JWA</dt>
        <dd>JSON Web Algorithms</dd>
        <dt>JWK</dt>
        <dd>JSON Web Key</dd>
      	<dt>JWE</dt>
      	<dd>JSON Web Encryption</dd>
        <dt>JWS</dt>
        <dd>JSON Web Signature</dd>
        <dt>JWT</dt>
        <dd>JSON Web Token</dd>
        <dt>LTI</dt>
        <dd>Learning Tools Interoperability</dd>
        <dt>MAC</dt>
        <dd>Message Authentication Code</dd>
        <dt>RFC</dt>
        <dd>Request for Comments</dd>
        <dt>SSL</dt>
        <dd>Secure Sockets Layer</dd>
        <dt>TLS</dt>
        <dd>Transport Layer Security</dd>
        <dt>URL</dt>
        <dd>Uniform Resource Locator</dd>
      </dl>
    </section>

    <section id="conformance">
      <h3>Conformance Statements</h3>
    </section>

  </section>
  <!-- /introduction -->
  <section>
    <h2>Security Architecture</h2>
    <section>
      <h3>Web Services-based Architectures</h3>
    	<p>Some IMS specifications describe a set of web service calls that can
    	occur between a service consumer (<a>Consumer</a>) and a service provider (<a>Platform</a>).
    	Typically a service call occurs between a Consumer and Platform when one 'pulls'
    	data from the other (using an  HTTP GET) or 'pushes' data (using HTTP PUT or POST) to the other.
    	<a href="#fig_wsa"></a> is a schematic representation of how this security framework expects a
    	Client and Platform to perform these service calls.
      <figure id="fig_wsa">
        <img height="300" src="files/images/fig2p1-fwsarchv1.jpg">
        <figcaption>Web services architecture</figcaption>
      </figure></p>
    	<p>Each IMS specification will define how the <a>Consumer</a> and
    		<a>Platform</a> will exchange information. When a service call must be done securely, the
    		sender MUST use this framework to secure the data transfer. This document defines how
    		to achieve the "Authentication and Authorization" portion of the schema represented in Figure 1
    		and how each data exchange will use this information. The "Authentication and Authorization"
    		portion of the exchange is based on the OAuth 2.0 protocol flow (as defined in [[!RFC6749]] section 1.2).
    		Sequences 'A' - 'D' in Figure 2 shows the abstract protocol flow for acquiring needed authorization
    		information, and sequences 'E' - 'F' show the the flow of using the authorization information
    		to perform the service call. Note that in Figure 2, the Client, as defined by OAuth 2.0, could be either the
    		<a>Platform</a> or <a>Consumer</a> depending on which entity initiates the exchange.
 			<figure id="fig_wsapf">
        		<img height="400" src="files/images/fig2p2-fwsabstractflowv1.jpg">
        		<figcaption>Web services abstract protocol flow</figcaption>
      		</figure>
    	</p>

    	<p>There are four functional components in the authentication and authorization flow:</p>
      <p><strong>Client</strong>. The system, application, or tool that requires
        access to the corresponding resource via a specific endpoint or set of endpoints.</p>
      <p><strong>Resource Owner</strong>. The system, application, or tool that owns
        the resource located at a specific endpoint or set of endpoints and which
        can provide permission to obtain access to that resource.</p>
      <p><strong>Authorization Server</strong>. The system responsible for allocating
        the appropriate access authorization using the authentication information
        supplied to it by the Client.
      </p>
      <p><strong>Resource Server</strong>. The system, application, or tool that makes
        the corresponding resource available via the specific endpoint or set of
        endpoints and that supports the defined authorization mechanism.</p>
    	<p>In general, a Client may obtain authorization through three phases:</p>
      <ol>
        <li>
          <p>Obtain authorization to resource (Phase 1) - denoted by sequence 'A' and
            'B' in Figure 2.</p>
        </li>
        <li>
          <p>Obtain the access information from the authorization server (Phase 2) -
            denoted by sequence 'C' and 'D' in the figure. If a system does not support
            Phase 1, the required permissions information SHOULD be obtained via
            some out-of-band process.
          </p>
        </li>
        <li>
          <p>Obtain access to the resource (Phase 3) - denoted by sequence 'E' and 'F'
            in the figure. If a system does not support Phase 2, then the required
            access information SHOULD be obtained via some out-of-band process.</p>
        </li>
      </ol>
    	<p>In most cases, as discussed in section 4, Clients and Platforms will only use
    		phase 3, relying on shared credentials obtained out-of-band (see OAuth 2.0 [[!RFC 6749]]
    		Section 4.4). Subsequently, only phase 3 MUST be supported.
    	</p>
    </section>
    <section>
      <h3>Non-Web Services-based Architectures</h3>
      <p>In the case where IMS has defined a non-web services based standard, the specification
        will describe the set of messages that can occur between a
        <a>Platform</a> and a <a>Tool</a>. In scenarios where the message exchange
        is vulnerable (for example, when launching from a web browser), the messages
        will be signed. This signing MAY include data derived from the identity-based
        authentication. For IMS specifications using a non-web services approach,
        <a href="#fig_nwsa"></a> shows a schematic representation of this security
        framework.
      </p>
      <figure id="fig_nwsa">
        <img height="300" src="files/images/fig2p3-nonwsarchv1.jpg">
        <figcaption>Non-web services architecture</figcaption>
      </figure>

      <p>The IMS specification defines how a <a>Tool</a> can transform the messages
        exchanged between the <a>Platform</a> and the Tool (including a user's
        browser-based interaction) into a Tool-based experience. This document
        defines how to achieve Authentication and Authorization using a separate
        set of message exchanges between Platform and Tool and how to encode the
        authorization and authentication information in JWT-based message signing
        of these message exchanges. The authorization and authentication process
        uses an authorization server which may be a system independent of the Platform
        or may be endpoints hosted by the Platform.</p>
    </section>
  </section>
  <!-- /Security Architecture -->

  <section>
    <h2>Transport Security</h2>
    <p>Senders and receivers of data should encrypt the data to ensure that third parties
      cannot read the data in transit (for example, by sniffing packets).</p>
    <p>Therefore <a>Platforms</a> and <a>Consumers</a> MUST send all requests and responses
      using Transport Layer Security (TLS). Exchange of the signed certificates for
      endpoints between Platforms and Consumers is beyond the scope of this specification.
      IMS advises implementers to refer to the various third-party certificate-signing
      services in order to obtain signed certificates.
    </p>
    <p>Implementers MUST support the use of TLS 1.2 (see [[!RFC5246]]). Implementers
      MUST NOT use Sockets Layer (SSL).</p>
  </section>
  <!-- /Transport Security -->
  <section>
    <h2>Securing Web Services</h2>
  	<section>
  		<h3>Using OAuth 2.0 Client-Credentials Grant</h3>
  		<p>When there is an established trust relationship between the resource owner, the resource server and
  			the system requiring access to the resource(s), the approach shown in <a href="#fig_oa2ccbra"></a> MUST
  			be used for the web services. It is assumed that the OAuth 2 Client is the <a>Consumer</a>
  			and the Resource Server the <a>Platform</a>. Authentication and Authorization requires
  			the use of OAuth 2.0 bearer tokens, obtained using the mechanism described
  			in Section 4.4 of [[!RFC6749]].</p>
  		<figure id="fig_oa2ccbra">
  			<img height="300" src="files/images/fig4p1-flowv1.jpg">
  				<figcaption>OAuth 2 client credentials based resource access</figcaption>
  		</figure>
  		<p>Making a secured web service request comprises two steps:</p>
  		<ol>
  			<li>
  				<p>Obtain an access token by sending a request to the Platform's OAuth 2 Access
  					Token service endpoint (as in flow 'C/D' in the figure);</p>
  			</li>
  			<li>
  				<p>Include the access token in the <code>Authorization</code> header of service
  					request messages (as in flow 'E/F' in the figure).</p>
  			</li>
  		</ol>
  		<p>Once obtained, the <a>Consumer</a> can freely re-use the access token up until
  			the token's expiry time, so that the Consumer need not repeat step 'C' for every
  			service request. The specific, appropriate mechanism for obtaining the set
  			of credentials is not within the scope of this document.</p>
  		<p>In IMS service specifications, scopes, as defined in [[!RFC6749]], MUST be
  			used when requesting an access token. The authorization server is responsible
  			for validating the scopes identified in the request and the response MUST include
  			a scope parameter which confirms this list or comprises a subset of the services
  			requested. The Authorization Server may refuse to provide an access token and
  			so MUST return an error response.</p>
  		<p><a>Consumers</a> MUST use the OAuth 2.0 Client Credentials grant type. In this
  			grant type, the Consumer can request an access token using only its credentials
  			(using its consumer key and secret information) in these cases:</p>
  		<ul>
  			<li>
  				<p>The <a>Consumer</a> is requesting access to the protected resources under
  					its control;
  				</p>
  			</li>
  			<li>
  				<p>The <a>Consumer</a> is requesting access to resources owned by another resource
  					owner that has previously arranged this access permission with the authorization
  					server.
  				</p>
  			</li>
  		</ul>
  		<p>In this approach, the <a>Consumer</a> issues a Consumer authentication request
  			and receives an access token in response. Section 5 of [[!RFC6749]] defines
  			the issuing of an access token. To obtain an access token for IMS service
  			access requires four pieces of configuration information:
  		</p>
  		<p><strong>Key</strong>. The public identifier for the communication exchange
  			(this is also referred to as the application ID).</p>
  		<p><strong>Secret</strong>. The shared secret for the communication exchange (this
  			is also referred to as the application secret).</p>
  		<p><strong>List of Scopes</strong>. The list of scopes that identify the set of
  			endpoints for which access permission is being requested.</p>
  		<p><strong>OAuth 2 Access Token Service Endpoint</strong>. The endpoint from which
  			the approved, requesting <a>Consumer</a> can obtain the access token.</p>
  		<p>Requests for an access token use an HTTP POST and TLS. The Consumer MUST use
  			its key and secret with the HTTP Basic Authentication method (as described
  			in [[!RFC2617]]) for this request and MUST NOT put its key, secret and list
  			of scopes into the request body. An example of the request message is shown
  			below in which three scopes (scopename1, scopename2 and scopenamex) are identified:
  		</p>
  		<pre><code>
      POST /token HTTP/1.1
      Host: server.example.com
      Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
      Content-Type: application/x-www-form-urlencoded

      grant_type=client_credentials&scope=scopename1%20scopename2%20scopenamex
    </code></pre>

  		<p>The recommended naming convention to be used for scopes is described in
  			<a href="#scope-naming-conventions"></a> of this document.</p>
  		<p>If the authorization service successfully grants this request (see Section
  			5.1 in [[!RFC6749]] for the detailed description), it responds with an HTTP
  			200 OK response containing the access token and its expiry lifetime (IMS
  			recommends a default expiry lifetime of 3600 seconds, one hour, for access
  			tokens) and confirms the set of scopes supported by this access token:</p>
  		<pre><code>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token" : "2YotnFZFEjr1zCsicMWpAA",
    "token_type" : "bearer",
    "expires_in" : 3600,
    "scope" : "scopename1 scopename2 scopenamex"
}
</code></pre>
  		<p>The <a>Consumer</a> utilizes the access token to authenticate with the resource
  			using the HTTP Authorization request header field [[!RFC2617]] with an authentication
  			scheme defined by the specification of the access token type used, such as
  			[[!RFC6750]]. For example, with a bearer-type token, a resource retrieval
  			request uses this form:</p>
  		<pre><code>
GET /resource/1 HTTP/1.1
Host: provider.example.com
Authorization: Bearer 2YotnFZFEjr1zCsicMWpAA
      </code></pre>
  		<p>The authorization server MAY decide not to issue an access token: this could
  			be because the request scopes are invalid, the credentials from the client
  			may be invalid, etc. In this case the authorization server MUST return an
  			error message (see Section 5.2 in [[!RFC6749]] for the detailed description)
  			with an HTTP 400 (Bad Request) status code. An example of the error response
  			message (when the requested scope is invalid) is:</p>
  		<pre><code>
HTTP/1.1 400 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "error" : "invalid_scope"
}
      </code></pre>

  		<section>
  			<h4>Using JSON Web Tokens with OAuth 2.0 Client-Credentials Grant</h4>
  			<p>In this approach, a <a>Consumer</a> generates a JWT [[!RFC7519]] bearer token
  				as a means for authentication in requesting an OAuth 2.0 access token, which
  				it can then use to authorize requests to services as per [[!RFC7523]].
  			</p>
  			<p>The JWT payload MUST contain at least the following <a>Claims</a>:</p>
  			<table>
  				<thead>
  					<tr>
  						<th>Claim</th>
  						<th>Description</th>
  					</tr>
  				</thead>
  				<tbody>
  					<tr>
  						<td><code>iss</code></td>
  						<td>A unique identifier for the entity that issued the JWT</td>
  					</tr>
  					<tr>
  						<td><code>sub</code></td>
  						<td>"client_id" of the OAuth <a>Consumer</a></td>
  					</tr>
  					<tr>
  						<td><code>aud</code></td>
  						<td>Authorization server identifier</td>
  					</tr>
  					<tr>
  						<td><code>iat</code></td>
  						<td>Timestamp for when the JWT was created</td>
  					</tr>
  					<tr>
  						<td><code>exp</code></td>
  						<td>Timestamp for when the JWT should be treated as having expired (after allowing a margin for clock skew)</td>
  					</tr>
  					<tr>
  						<td><code>jti</code></td>
  						<td>A unique (potentially reusable) identifier for the token</td>
  					</tr>
  				</tbody>
  			</table>
  			<pre><code>
{
    "iss" : "tool.com",
    "sub" : "www.example.com",
    "aud" : "https://www.example.com/lti/auth/token",
    "iat" : "1485907200",
    "exp" : "1485907500",
    "jti" : "29f90c047a44b2ece73d00a09364d49b"
}
      </code></pre>
  			<p>The <code>aud</code> <a>Claim</a> MUST contain a value that identifies the
  				authorization server as an intended audience. The <a>Consumer</a> MAY use the
  				token endpoint URL of the authorization server as a value for an
  				<code>aud</code> element to identify the authorization server as an intended
  				audience of the JWT. The authorization server MUST reject any JWT that does
  				not contain its own identity as the intended audience.</p>
  			<p>The <code>iat</code> <a>Claim</a> MUST be the time at which the
  				<a>Consumer</a> generated the JWT.
  			</p>
  			<p>The <code>exp</code> <a>Claim</a> MUST be an absolute expiry time for the message
  				(typically five minutes after the <code>iat</code> timestamp); the
  				<a>Consumer</a> MUST honour this expiry time, though it MAY also choose to
  				expire the JWT at an earlier time (but no earlier than the
  				<code>iat</code> value). This
  				<code>exp</code> timestamp SHOULD also indicate when the
  				<code>jti</code> value expires and could be re-used.</p>
  			<p>The <a>Consumer</a> MAY include other top-level <a>Claims</a> in the JWT and,
  				if it does so, the authorization server MAY ignore them.</p>
  			<p>The above JSON structure represents the first, payload element of the JWT.
  				The <a>Consumer</a> MUST also add a second, header element, referred to as
  				the JSON Object Signing and Encryption (JOSE) header, that defines the algorithm
  				it used to sign the token.</p>
  			<pre><code>
{
    "typ" : "JWT",
    "alg" : "RS256"
}
      </code></pre>
  			<p>The <a>Consumer</a> MUST generate a third, signature element by applying the
  				algorithm to the contents of both the header and payload elements (see [[!RFC7515]]
  				for how to create a JSON Web Signature, JWS). The <a>Consumer</a> then
  				forms the value of the JWT by separately base-64 encoding each of the three
  				elements and concatenating them with a period (<code>.</code>) as a separator
  				character i.e.
  			</p>
  			<pre><code>
JWT = base64_encode(JOSE Header).base64_encode(Claim Set Payload).base64_encode(JWS Signature)
      </code></pre>
  			<p>creating a JWT of (line breaks added for clarity):</p>
  			<pre><code>
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
.eyJpc3MiOiJ0b29sLmNvbSIsInN1YiI6Ind3dy5leGFtcGxlLmNvbSIsImF1ZCI6Imh0dHBzOi8vd3d3Lm
V4YW1wbGUuY29tL2x0aS9hdXRoL3Rva2VuIiwiaWF0IjoiMTQ4NTkwNzIwMCIsImV4cCI6IjE0ODU5MDc1
MDAiLCJqdGkiOiIyOWY5MGMwNDdhNDRiMmVjZTczZDAwYTA5MzY0ZDQ5YiJ9
.liArqLDIF-xGcCu8ythy0HlzntxwZ90AYTnwH-daCQQ
      </code></pre>
  			<p>The <a>Consumer</a>'s resulting authorization request uses the following POST
  				parameters:
  			</p>
  			<ul>
  				<li>
  					<p><code>grant_type</code>: <code>client_credentials</code></p>
  				</li>
  				<li>
  					<p><code>client_assertion_type</code>: <code>urn:ietf:params:oauth:client-assertion-type:jwt-bearer</code></p>
  				</li>
  				<li>
  					<p><code>client_assertion</code>: the <a>Consumer</a>'s generated JWT</p>
  				</li>
  				<li>
  					<p><code>scope</code>: <code>https://purl.imsglobal.org/spec/lti-ags/lineitem https://purl.imsglobal.org/spec/lti-ags/result/read</code></p>
  				</li>
  			</ul>
  			<p>This leads to a request with the following form (with line breaks for clarity):</p>
  			<pre><code>
POST /lti/auth/token HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer
&client_assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
.eyJpc3MiOiJ0b29sLmNvbSIsInN1YiI6Ind3dy5leGFtcGxlLmNvbSIsImF1ZCI6Imh0dHBzOi8vd3d3LmV4YW1wbGUuY29tL2x0aS9hdXRoL3R
va2VuIiwiaWF0IjoiMTQ4NTkwNzIwMCIsImV4cCI6IjE0ODU5MDc1MDAiLCJqdGkiOiIyOWY5MGMwNDdhNDRiMmVjZTczZDAwYTA5MzY0ZDQ5YiJ9
.liArqLDIF-xGcCu8ythy0HlzntxwZ90AYTnwH-daCQQ
&scope=http%3A%2F%2Fimsglobal.org%2Fags%2Flineitem%20http%3A%2F%2Fimsglobal.org%2Fags%2Fresult%2Fread
</code></pre>
  			<p>The authorization server decodes the JWT and checks the <code>iss</code>,
  				<code>sub</code>,
  				<code>exp</code>, <code>aud</code> and <code>jti</code> values, followed
  				by verifying the signature. If it finds the request to be a valid, it generates
  				and returns an access token, with a response of this form:</p>
  			<pre><code>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token" : "dkj4985kjaIAJDJ89kl8rkn5",
    "token_type" : "Bearer",
    "expires_in" : 3600,
    "scope" : "https://purl.imsglobal.org/spec/lti-ags/lineitem https://purl.imsglobal.org/spec/lti-ags/result/read"
}
</code></pre>
  			<p>The token MUST ONLY contain ASCII characters (0x20-0x7A) and SHOULD be at least
  				15 characters in length. The token MAY be a JWT (see below). IMS recommends
  				a default expiry time of 1 hour (3600 seconds). The bearer of the token can
  				use it until the token expires (as evidenced by a failed request) but IMS
  				recommends that a <a>Consumer</a> manages tokens such that once they have expired
  				(allowing for clock skew between the systems), it requests a new one when
  				needed.
  			</p>
  			<section>
  				<h4>Using a JWT as an Access Token</h4>
  				<p><a>Consumers</a> SHOULD treat the access token returned by the authorization server
  					as an opaque string. Any meaning that the token may have is relevant only
  					to the authorization server and resource provider. If a resource provider
  					does not wish to manage access tokens, it can use a JWT to encapsulate
  					the details of the token so that the bearer provides the details with each
  					service request for verification.
  				</p>
  				<p>Following from the above example, this might be the access JWT token's payload:
  				</p>
  				<pre><code>
{
    "sub" : "www.example.com",
    "iat" : "1485907200",
    "exp" : "1485907500",
    "imsglobal.org.security.scope" : "https://purl.imsglobal.org/spec/lti-ags/lineitem https://purl.imsglobal.org/spec/lti-ags/result/read"
}
</code></pre>
  				<p>This might be the JWT's header:</p>
  				<pre><code>
{
    "typ" : "JWT",
    "alg" : "RS256"
}
</code></pre>
  				<p>After signing, this would create the JWT:</p>
  				<pre><code>
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ3d3cuZXhhbXBsZS5jb20iLCJpYXQiOiIxNDg1OTA3MjAwIiwiZXhwIjoiMTQ4NTkwNzUwMCIsImltc2dsb2JhbC5vcmcuc2VjdXJpdHkuc2NvcGUiOiJMdGlMaW5rU2V0dGluZ3MgU2NvcmUuaXRlbS5QVVQifQ.UWCuoD05KDYVQHEcciTV88YYtWWMwgb3sTbrjwxGBZA
        </code></pre>
  				<p>Thus, the authorization server might return this access token in a response
  					like this:</p>
  				<pre><code>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token" : "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJ3d3cuZXhhbXBsZS5jb20iLCJpYXQiOiIxNDg1OTA3MjAwIiwiZXhwIjoiMTQ4NTkwNzUwMCIsImltc2dsb2JhbC5vcmcuc2VjdXJpdHkuc2NvcGUiOiJMdGlMaW5rU2V0dGluZ3MgU2NvcmUuaXRlbS5QVVQifQ.UWCuoD05KDYVQHEcciTV88YYtWWMwgb3sTbrjwxGBZA",
    "token_type" : "Bearer",
    "expires_in" : 3600,
    "scope" : "https://purl.imsglobal.org/spec/lti-ags/lineitem https://purl.imsglobal.org/spec/lti-ags/result/read"
}
        </code></pre>
  				<p>When the resource provider receives a service request with this access token,
  					it can verify the signature and extract the details of the validity of
  					the request from the JWT before proceeding to process the request.</p>
  			</section>
  		</section>
    </section>

  	<section>
  		<h3>Using OAuth 2.0 Authorization Code Grant</h3>
  		<p>In scenarios where the learner or another third party is the resource owner, there will not be a pre-established trust relationship.
  			Therefore the client credentials approach is insufficient. Instead IMS RECOMMEND the use of OAuth 2.0 Authorization Code Grant.
  			<a href="#fig_oa2ag"></a> shows the assumed system architecture when the resource owner is required to provide explicit permission
  			for access to a resource. It is assumed that the OAuth 2 Client is the <a>Consumer</a>
  			and the Resource Server the <a>Platform</a>.  The User Agent could be a Browser. Authentication and Authorization requires
  			the use of OAuth 2.0 bearer tokens, obtained using the mechanism described in Section 4.1 of [[!RFC6749]].</p>
  		<figure id="fig_oa2ag">
  			<img height="500" src="files/images/fig4p2-flowv1.jpg">
  				<figcaption>OAuth 2 authorization code grant based resource access</figcaption>
  		</figure>
  		<p>Making a secured web service request using authorization code grant comprises three steps:</p>
  		<ol>
  			<li>
  				<p>Obtain an authorization code using a choreography between the Consumer, User Agent, Resource Owner and Authorization Server (as in flow A/U/B in the figure);</p>
  			</li>
  			<li>
  				<p>Obtain an access token by sending a request, using the previously obtained authorization code, to the Platform's OAuth 2 Access
  					Token service endpoint (as in flow 'C/D' in the figure);</p>
  			</li>
  			<li>
  				<p>Include the access token in the <code>Authorization</code> header of service
  					request messages (as in flow 'E/F' in the figure).</p>
  			</li>
  		</ol>
  		<p>Once obtained, the <a>Consumer</a> can freely re-use the access token up until
  			the token's expiry time, so that the Consumer need not repeat step 'C' for every
  			service request. Token refresh is also available and if adopted MUST be used as described in [[!RFC6749]] Section 5.2</p>
  		<p>In IMS service specifications, scopes, as defined in [[!RFC6749]], MUST be
  			used when requesting an access token. The authorization server is responsible
  			for validating the scopes identified in the request and the response MUST include
  			a scope parameter which confirms this list or comprises a subset of the services
  			requested. The Authorization Server may refuse to provide an access token and
  			so MUST return an error response.</p>
  		<p>The <a>Consumer</a> initiates the flow by directing the resource owner’s
  			user-agent to the authorization endpoint (flow (A) in the figure).  All exchanges MUST use TLS. The Consumer includes
  			its client identifier, requested scope, local state, and a
  			redirection URI to which the authorization server will send the
  			user-agent back once access is granted (or denied).  For IMS, the query parameters 'scope' and 'state' MUST be used.
  			An example of the request is shown below in which one scope (scopename1) is identified:</p>
  		<pre><code>
      GET /authorize?gresponse_type=code&client_id=s6BhdRkqt3&state=xyz&scope=scopename1&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1
      Host: server.example.com
    </code></pre>
  		<p>If the resource owner grants the access request, the authorization
  			server issues an authorization code and delivers it to the Consumer by
  			adding the specific parameters to the query component of the
  			redirection URI (flow (B) in the figure). For example, the authorization server redirects the user-agent by
  			sending the following HTTP response</p>
  		<pre><code>
      HTTP/1.1 302 Found
      Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA&state=xyz
    </code></pre>
  		<p>This authorization code MUST only be used once. A lifetime for the authorization
  			code of 600 seconds (10 minutes) is RECOMMENDED.
  			If an authorization code is used more than
  			once, the authorization server MUST deny the request and SHOULD
  			revoke (when possible) all tokens previously issued based on
  			that authorization code.  The authorization code is bound to
  			the client identifier and redirection URI.</p>
  		<p>If the resource owner denies the access request or if the request
  			fails for reasons other than a missing or invalid redirection URI,
  			the authorization server informs the client by adding the following
  			parameters to the query component of the redirection URI. For example:</p>
  		<pre><code>
      HTTP/1.1 302 Found
      Location: https://client.example.com/cb?error=access_denied&state=xyz
    </code></pre>
  		<p>The next step is use the authorization code to obtain the access token (flow (C) in the figure).
  			Requests for an access token use an HTTP POST and TLS. The Consumer MUST use
  			its key and secret with the HTTP Basic Authentication method (as described
  			in [[!RFC2617]]) for this request and MUST NOT put its key and secret into the
  			request body. An example of the request message is shown below:
  		</p>
  		<pre><code>
      POST /token HTTP/1.1
      Host: server.example.com
      Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW
      Content-Type: application/x-www-form-urlencoded

      grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA&scope=scopename1&redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb
    </code></pre>
  		<p>If the authorization service successfully grants this request (see Section
  			5.1 in [[!RFC6749]] for the detailed description), it responds with an HTTP
  			200 OK response (flow (D) in the figure) containing the access token and its expiry lifetime (IMS
  			recommends a default expiry lifetime of 3600 seconds, one hour, for access
  			tokens) and confirms the scopes:</p>
  		<pre><code>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token" : "2YotnFZFEjr1zCsicMWpAA",
    "token_type" : "example",
    "expires_in" : 3600,
    "scope" : scopename1,
    "refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA"
}
</code></pre>
  		<p><b>EDITOR NOTE: What value do we want to be assigned for the 'token_type' (the value of 'example' is just a placeholder)?</b></p>
  		<p>The <a>Consumer</a> utilizes the access token to authenticate with the resource
  			using the HTTP Authorization request header field [[!RFC2617]] with an authentication
  			scheme defined by the specification of the access token type used, such as
  			[[!RFC6750]]. For example, with a bearer-type token, a resource retrieval
  			request uses this form (flow (E) in the figure):</p>
  		<pre><code>
GET /resource/1 HTTP/1.1
Host: provider.example.com
Authorization: Bearer 2YotnFZFEjr1zCsicMWpAA
      </code></pre>
  		<p>The authorization server MAY decide not to issue an access token: this could
  			be because the request scopes are invalid, the credentials from the client
  			may be invalid, etc. In this case the authorization server MUST return an
  			error message (see Section 5.2 in [[!RFC6749]] for the detailed description)
  			with an HTTP 400 (Bad Request) status code. An example of the error response
  			message (when the requested scope is invalid) is:</p>
  		<pre><code>
HTTP/1.1 400 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "error" : "invalid_scope"
}
      </code></pre>
  		<section>
  			<h4>Using JSON Web Tokens with OAuth 2.0 Authorization Code Grant</h4>
  			<p>In this approach, a <a>Consumer</a> generates a JWT [[!RFC7519]] bearer token
  				as a means for authentication in requesting an OAuth 2.0 access token, which
  				it can then use to authorize requests to services as per [[!RFC7523]]. This is
  				similar to the approach for using JSON Web Tokens with OAuth 2.0 Client-Credentials
  				Grant (see Section 4.1). The JWT payload MUST use the same set of claims as list in Section 4.1.
  				When using the same set of values as per Section 4.1 this leads to a request with the following form (with line breaks for clarity):
  			</p>
  			<pre><code>
POST /lti/auth/token HTTP/1.1
Host: www.example.com
Content-Type: application/x-www-form-urlencoded

grant_type=authorization_code&code=n0esc3NRze7LTCu7iYzS6a5acc3f0ogp4&client_assertion_type=urn%3Aietf%3Aparams%3Aoauth%3Aclient-assertion-type%3Ajwt-bearer
&client_assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
.eyJpc3MiOiJ0b29sLmNvbSIsInN1YiI6Ind3dy5leGFtcGxlLmNvbSIsImF1ZCI6Imh0dHBzOi8vd3d3LmV4YW1wbGUuY29tL2x0aS9hdXRoL3R
va2VuIiwiaWF0IjoiMTQ4NTkwNzIwMCIsImV4cCI6IjE0ODU5MDc1MDAiLCJqdGkiOiIyOWY5MGMwNDdhNDRiMmVjZTczZDAwYTA5MzY0ZDQ5YiJ9
.liArqLDIF-xGcCu8ythy0HlzntxwZ90AYTnwH-daCQQ
&scope=http%3A%2F%2Fimsglobal.org%2Fags%2Flineitem%20http%3A%2F%2Fimsglobal.org%2Fags%2Fresult%2Fread
</code></pre>
  			<p>The authorization server decodes the JWT and checks the <code>iss</code>,
  				<code>sub</code>,
  				<code>exp</code>, <code>aud</code> and <code>jti</code> values, followed
  				by verifying the signature. If it finds the request to be a valid, it generates
  				and returns an access token, with a response of this form:</p>
  			<pre><code>
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
    "access_token" : "dkj4985kjaIAJDJ89kl8rkn5",
    "token_type" : "example",
    "expires_in" : 3600,
    "scope" : "https://purl.imsglobal.org/spec/lti-ags/lineitem https://purl.imsglobal.org/spec/lti-ags/result/read"
}
</code></pre>
  			<p><b>EDITOR NOTE: What value do we want to be assigned for the 'token_type' (the value of 'example' is just a placeholder)?</b></p>
  			<p>The token MUST ONLY contain ASCII characters (0x20-0x7A) and SHOULD be at least
  				15 characters in length. The token MAY be a JWT (see below). IMS recommends
  				a default expiry time of 1 hour (3600 seconds). The bearer of the token can
  				use it until the token expires (as evidenced by a failed request) but IMS
  				recommends that a <a>Consumer</a> manages tokens such that once they have expired
  				(allowing for clock skew between the systems), it requests a new one when
  				needed.
  			</p>
  			<section>
  				<h4>Using a JWT as an Access Token</h4>
  				<p>As in the case of Client Credentials, the access token itself could be a JWT. Therefore
  					<a>Consumers</a> SHOULD treat the access token returned by the authorization server
  					as an opaque string. Any meaning that the token may have is relevant only
  					to the authorization server and resource provider. If a resource provider
  					does not wish to manage access tokens, it can use a JWT to encapsulate
  					the details of the token so that the bearer provides the details with each
  					service request for verification.
  				</p>
  			</section>
  		</section>
  	</section>
  </section>
  <!--/ Securing Web Services -->


  <section>
    <h2>Message Security and Message Signing</h2>
    <p>When transferring a User Agent from one entity to another the redirecting party
      SHOULD sign the <a>Message</a> effecting this transfer using a JWT. Messages
      are JWTs sent through the browser by auto-POSTing from sender to some endpoint
      URL on the message receiver. The signature on the JWT is always signed by the
      private key of the message sender. Thus, for platform-to-tool messages, the
      platform signs the JWT with their private key, and the client then verifies
      the signature on the message payload they receive by using the platform's public
      key they obtained out-of-band. In an example out-of-band registration workflow,
      the public-key/key-set-URL exchange can happen during <a>Tool</a> registration:
      the
    	<a>Platform</a> registers the Consumer, gives the Consumer its public-key/key-set-URL;
    	the Consumer reciprocates.
    </p>
    <p>A <a>Message</a> MAY carry additional <a>Claims</a> related to the user interface
      flow presented to the end user: these Claims MUST be defined in the corresponding
      specification (for example, the LTI Specifications [[LTI-13]], which defines
      the concepts of LTI-compliant platforms and tools).</p>
    <section>
      <h3>Platform-Originating Messages</h3>
      <p>When a <a>Platform</a> acts as an Identity Provider (IDP), it MUST pass identity
      	information with each <a>Message</a>. To do so, it MUST use a subset of Section 2 of
      	OpenID Connect Core [[!OPENID-CCORE]] (see section 5.1.1 for more details) to provide user Authentication to the
        Tool (see <a href="#fig_ifpom"></a> for a schematic representation of this
        architecture). This is done using a modified version of the Implicit Flow
        of the OpenID Connect Core [[!OPENID-CCORE]] (section 3.2.1) where steps 1-4 are ommitted. The authentication relies upon the
      	<a>Platform</a> and <a>Tool</a> being aware of various identifiers for
        each other as well as using public key encryption for signing the messages.</p>
      <figure id="fig_ifpom">
        <img height="400" src="files/images/fig5p1-platformtoclientv1.jpg">
        <figcaption>Information flow for platform-originating messages</figcaption>
      </figure>
      <p>The key points in the figure above are:</p>
      <ul>
        <li>
        	<p>The <a>Tool</a> must have been allocated an OAuth 2 client_id (usually
            by an Authorization Server and this may be owned by the <a>Platform</a>);</p>
        </li>
        <li>
        	<p>The <a>Platform</a> must be given the client_id for the Tool (using some
            out-of-band registration process if not assigned by the Platform);</p>
        </li>
        <li>
        	<p>The <a>Tool</a> must be given the <a>Public Key</a> and
            <a>Issuer Identifier</a> (issuer_id) for the <a>Platform</a> (using some
            out-of-band registration process). See <a href="#h_key-management"></a> for more details on Key Management;</p>
        </li>
        <li>
          <p>The <a>Platform</a> must have the <a>Private Key</a> pair to its announced
            <a>Public Key</a> and a set of Subject identifiers (subject_id) for the
            set of users that will be given access to the <a>Tool</a>.</p>
        </li>
      </ul>
      <p>Since the user is already Authenticated to the <a>Issuer</a> (the <a>Platform</a>),
        the Issuer is pre-configured with the endpoints, and as the Authorized user
        has already granted consent/permission for logging users into the endpoint,
        system steps 1-4 are omitted from OpenID Connect Core [[!OPENID-CCORE]].
        There is no support for sending the access token as part of Step 5.</p>
      <p>Starting from step 5, the Implicit Flow follows these steps:</p>
      <ol>
        <li>
        	<p>The authorization server sends the end user to the <a>Tool</a> via a
            form post with an ID token;
          </p>
        </li>
        <li>
        	<p>The <a>Tool</a> validates the ID token and retrieves the end user's Subject
            Identifier.
          </p>
        </li>
      </ol>
      <p>The User information passed upon launch depends upon relevant privacy settings
        the <a>Platform</a> must apply. At a minimum, the Platform must present a
        permanent identifier for the user in the <code>sub</code> <a>Claim</a>.</p>
      <section>
        <h4>ID Token</h4>
        <p>In order to enable the authentication of end users, OpenID Connect extends
          OAuth 2.0 with the ID Token data structure. The ID Token is a security
          token that contains <a>Claims</a> about the Authentication of an end user
        	made by an authorization server when using a <a>Tool</a>, and potentially
          other requested Claims. The ID Token is represented as a JWT [[!RFC7519]]
          and the JWS is produced using the <a>Platform</a>'s <a>Private Key</a>. See section 2 of [[!OPENID-CCORE]]
        for more information regarding the ID Token.</p>
        <p>The ID Token uses these <a>Claims</a>:</p>
        <dl>
          <dt>iss</dt>
          <dd>REQUIRED. <a>Issuer Identifier</a> for the <a>Issuer</a> of the message
            i.e. the <a>Platform</a>. The <code>iss</code> value is a case-sensitive
            URL using the HTTPS scheme that contains: scheme, host; and, optionally,
            port number, and path components; and, no query or fragment components.</dd>

          <dt>aud</dt>
        	<dd>REQUIRED. Audience(s) for whom this ID Token is intended i.e. the <a>Tool</a>.
        	It MUST contain the OAuth 2.0 client_id of the Tool as an audience
            value. It MAY also contain identifiers for other audiences. In the general
            case, the <code>aud</code> value is an array of case-sensitive strings.
            In the common special case when there is one audience, the
            <code>aud</code> value MAY be a single case-sensitive string.
          </dd>
          <dt>sub</dt>
          <dd>REQUIRED. <a>Subject Identifier</a>. A locally unique and never reassigned
            identifier within the Issuer for the end user, which is intended to be
            consumed by the <a>Tool</a>, (for example, it might be something like
            24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4). It MUST NOT exceed
            255 ASCII characters in length. The <code>sub</code> value is a case-sensitive
            string. This MUST be the same value as the <a>Platform's</a> User ID
            for the end user.</dd>
          <dt>exp</dt>
        	<dd>REQUIRED. Expiration time on or after which the <a>Tool</a> MUST NOT
            accept the ID Token for processing. When processing this parameter, the
            Tool MUST verify that the time expressed in this <a>Claim</a> occurs
            after the current date/time. Implementers MAY provide for some small
            leeway, usually no more than a few minutes, to account for clock skew.
            This Claim's value MUST be a JSON number representing the number of seconds
            offset from 1970-01-01T00:00:00Z (UTC). See [[!RFC3339]] for details
            regarding date/times in general and UTC in particular.</dd>
          <dt>iat</dt>
          <dd>REQUIRED. Time at which the <a>Issuer</a> generated the JWT. Its value
            is a JSON number representing the number of seconds offset from 1970-01-01T00:00:00Z
            (UTC) until the generation time.</dd>
          <dt>nonce</dt>
        	<dd>REQUIRED. String value used to associate a <a>Tool</a> session with an
            ID Token, and to mitigate replay attacks. The nonce value is a case-sensitive
            string.
          </dd>
          <dt>azp</dt>
          <dd>OPTIONAL. Authorized party - the party to which the ID Token was issued.
            If present, it MUST contain the OAuth 2.0 <a>Tool</a> ID of this party.
            This <a>Claim</a> is only needed when the Token has a single audience
            value and that audience is different than the authorized party. It MAY
            be included even when the authorized party is the same as the sole audience.
            The <code>azp</code> value is a case-sensitive string containing a StringOrURI
            value.
          </dd>
        </dl>
        <p>The <a>Claims</a> in an ID Token JWT might look like this (non-normative)
          example:
        </p>
        <pre><code>
{
    "iss": "https://lms.uofexample.edu",                // Platform Issuer Identifier
    "sub": "24400320",                                  // Subject Identifier of the User
    "aud": "s6BhdRkqt3",                                // Client Identifier for the Client
    "nonce": "n-0S6_WzA2Mj",
    "exp": 1311281970,
    "iat": 1311280970
}
        </code></pre>
      </section>
      <section>
        <h4>Successful Authentication</h4>
        <p>The Platform MUST send this parameter via the OAuth 2 Form Post [[!OAUTH2-FPRM]]:</p>
        <dl><dt>id_token</dt>
          <dd>REQUIRED. ID Token.</dd>
        </dl>
      </section>
      <section>

        <h4>Authentication Response Validation</h4>
      	<p><a>Tools</a> MUST validate the ID Token in the token response in the following
          manner:
        </p>
        <ol>
          <li>
          	<p>The <a>Tool</a> MUST <a>Validate</a> the signature of the ID Token
             according to JSON Web Signature [[!RFC7515]], Section 5.2 using the
          	<a>Public Key</a> from the Platform;
            </p>
          </li>
          <li>
            <p>The <a>Issuer Identifier</a> for the <a>Platform</a> MUST exactly match
              the value of the
              <code>iss</code> (Issuer) <a>Claim</a> (therefore the
            	<a>Tool</a> MUST previously have been made aware of this identifier);
            </p>
          </li>
          <li>
          	<p>The <a>Tool</a> MUST validate that the <code>aud</code> (audience)
              <a>Claim</a> contains its client_id value registered as an audience
              with the <a>Issuer</a> identified by the
              <code>iss</code> (Issuer) <a>Claim</a>. The <code>aud</code> (audience)
              Claim MAY contain an array with more than one element. The
          		<a>Tool</a> MUST reject the ID Token if it does not list the client_id
              as a valid audience, or if it contains additional audiences not trusted
              by the Tool. The request mesage will be rejected with a HTTP code
              of 401;
            </p>
          </li>
          <li>
          	<p>If the ID Token contains multiple audiences, the <a>Tool</a> SHOULD
              verify that an <code>azp</code> <a>Claim</a> is present;</p>
          </li>
          <li>
            <p>If an <code>azp</code> (authorized party) <a>Claim</a> is present, the
            	<a>Tool</a> SHOULD verify that its client_id is the Claim's value;</p>
          </li>
          <li>
            <p>The <code>alg</code> value SHOULD be the default of RS256 or the algorithm
            	sent by the <a>Tool</a> in the id_token_signed_response_alg parameter
              during its registration. Use of algorithms other that RS256 will limit
              interoperability;
            </p>
          </li>
          <li>
            <p>The current time MUST be before the time represented by the
              <code>exp</code> <a>Claim</a>;
            </p>
          </li>
          <li>
          	<p>The <a>Tool</a> MAY use the <code>iat</code> <a>Claim</a> to reject
              tokens that were issued too far away from the current time, limiting
              the amount of time that it needs to store nonces used to prevent attacks.
              The Tool MAY define its own acceptable time range;
            </p>
          </li>
          <li>
            <p>The ID Token MUST contain a <code>nonce</code> <a>Claim</a>. The
            	<a>Tool</a> SHOULD verify that it has not yet received this nonce
            	value (within a Tool-defined time window), in order to help prevent
            	replay attacks. The Tool MAY define its own precise method for detecting
              replay attacks.</p>
          </li>
        </ol>
      </section>
    </section>
    <section>
    	<h3>Tool-Originating Messages</h3>
      <p>When a <a>Message</a> does not assert the user identity, the sender signs and
        secures the JWT using the JSON Web Signature (JWS) defined in [[!RFC7515]].
        The <a>Tool</a> typically sends such messages to the
        <a>Platform</a>. <a href="#fig_ifcom"></a> is a schematic representation
        of this architecture.</p>

      <figure id="fig_ifcom">
        <img height="400" src="files/images/fig5p2-clienttoplatformv1.jpg">
        <figcaption>Information flow for tool-originating messages</figcaption>
      </figure>
      <p>The key points in the figure above are:</p>
      <ul>
        <li>
        	<p>The <a>Tool</a> must have been allocated an OAuth 2 client_id (usually
            by an Authorization Server and this may be owned by the <a>Platform</a>)</p>
        </li>
        <li>
          <p>The <a>Platform</a> must be given the <a>Public Key</a> and client_id for
          	the Tool (using some out-of-band registration process if not assigned
            by the Platform). See <a href="#h_key-management"></a> for more details
            on Key Management.</p>
        </li>
        <li>
        	<p>The <a>Tool</a> must be given the <a>Issuer Identifier</a> (issuer_id)
            for the <a>Platform</a> (using some out-of-band registration process)</p>
        </li>
        <li>
        	<p>The <a>Tool</a> must have the <a>Private Key</a> pair to its announced
            <a>Public Key</a>.</p>
        </li>
      </ul>
      <section>
        <h4>Form Parameter</h4>
        <p>The sender sends the JWT via a form HTTP post with a single parameter:</p>
        <p><strong>JWT</strong> (REQUIRED). JWS-signed token containing the <a>Message</a>
          <a>Claims</a>. The JWS is produced using the <a>Tool's</a> <a>Private Key</a>.</p>
      </section>
      <section>
      	<h4>Tool JWT</h4>
      	<p>The <a>Tool</a> JWT is a security token which contains <a>Claims</a> about
          the Authentication of an end user made by an authorization server when
          using a Tool, and potentially other requested Claims. The Tool JWT
          is represented as a JWT [[!RFC7519]].</p>
      	<p>The Tool JWT uses these claims:</p>
        <dl>
          <dt>iss</dt>
          <dd>REQUIRED. <a>Issuer Identifier</a> for the Issuer of the message i.e. the
          	Tool. It must be the OAuth 2.0 client_id of the Tool (this MAY be
          	provided to it by the <a>Platform</a> upon registration of the Tool).
          </dd>
          <dt>aud</dt>
        	<dd>REQUIRED. Audience(s) for whom this Tool JWT is intended. It MUST contain
            the case-sensitive URL used by the <a>Platform</a> to identify itself
            as an <a>Issuer</a> in platform-originating <a>Messages</a>. In the common
            special case when there is one audience, the <code>aud</code> value MAY
            be a single case-sensitive string.
          </dd>
          <dt>exp</dt>
          <dd>REQUIRED. Expiration time on or after which the <a>Platform</a> MUST NOT
          	accept the <a>Tool</a> JWT for processing. When processing this parameter,
            the Platform MUST verify that the time expressed in this
            <a>Claim</a> occurs after the current date/time. Implementers MAY provide
            for some small leeway, usually no more than a few minutes, to account
            for clock skew. This Claim's value MUST be a JSON number representing
            the number of seconds offset from 1970-01-01T00:00:00Z (UTC). See [[!RFC3339]]
            for details regarding date/times in general and UTC in particular.
          </dd>
          <dt>iat</dt>
        	<dd>REQUIRED. Time at which the <a>Issuer</a> generated the Tool JWT. Its
            value is a JSON number representing the number of seconds offset from
            1970-01-01T00:00:00Z (UTC) until the generation time.</dd>
          <dt>nonce</dt>
        	<dd>REQUIRED. String value used to associate a Tool session with a Tool JWT,
            and to mitigate replay attacks. The nonce value is a case-sensitive string.
          </dd>
          <dt>azp</dt>
        	<dd>OPTIONAL. Authorized party - the party to which the Tool JWT was issued.
            If present, it MUST contain the same value as in the
            <code>aud</code> <a>Claim</a>. The
            <code>azp</code> value is a case-sensitive string containing a StringOrURI
            value.
          </dd>
        </dl>

      	<p>The <a>Claims</a> in a Tool JWT might look like this (non-normative) example:</p>
        <pre><code>
{
    "iss": "s6BhdRkqt3",                                 // Client Identifier of the Client
    "aud": "https://lms.uofexample.edu",                 // Platform Issuer Identifier
    "nonce": "n-0S6_WzA2Mj",
    "exp": 1311281970,
    "iat": 1311280970
}
</code></pre>
      </section>
      <section>
        <h4>Authentication Response Validation</h4>
      	<p><a>Platforms</a> MUST <a>Validate</a> the Message Tool JWT in the Token
          Response in the following manner:
        </p>
        <ol>
          <li>
            <p>The <a>Platform</a> MUST validate the signature of the
            	<a>Tool</a> JWT according to JSON Web Signature [[!RFC7518]] using
            	the algorithm the Tool specifies in the <code>alg</code> header parameter
            	of the JOSE Header. The Platform must use the Pubic Key from the Tool
              to validate the message;</p>
          </li>
          <li>
          	<p>The client_id for the <a>Tool</a> MUST exactly match the value of the
              <code>iss</code> (Issuer) <a>Claim</a>;
            </p>
          </li>
          <li>
            <p>The <a>Platform</a> MUST validate that the <code>aud</code> (audience)
              <a>Claim</a> contains its advertised <a>Issuer</a> URL. The Platform
            	must reject the <a>Tool</a> JWT if it does not list the Platform
              as a valid audience, or if it contains additional audiences not trusted
              by the Platform;</p>
          </li>
          <li>
            <p>If the Token contains multiple audiences, the <a>Platform</a> SHOULD
              verify that an
              <code>azp</code> <a>Claim</a> is present;</p>
          </li>
          <li>
            <p>If an <code>azp</code> (authorized party) <a>Claim</a> is present, the
              <a>Platform</a> SHOULD verify that its <a>Issuer</a> URL is the Claim
              Value.
            </p>
          </li>
          <li>
            <p>The <code>alg</code> value SHOULD be the default of RS256 or the algorithm
              specified by the <a>Platform</a> to the Tool during registration;</p>
          </li>
          <li>
            <p>The current time MUST be before the time represented by the
              <code>exp</code> <a>Claim</a>;
            </p>
          </li>
          <li>
            <p>The <a>Platform</a> MAY use the <code>iat</code> to reject tokens that
              were issued to far away from the current time, limiting the amount
              of time that it needs to store nonces used to prevent attacks. The
              Platform MAY define its own acceptable time range;</p>
          </li>
          <li>
          	<p>The <a>Tool</a> JWT MUST contain a <code>nonce</code> <a>Claim</a>.
              The <a>Platform</a> SHOULD verify that it has not yet received this
              nonce value (within a Platform-defined time window), in order to prevent
              replay attacks. The Platform MAY define its own precise method for
              detecting replay attacks.
            </p>
          </li>
        </ol>
      </section>
    </section>
    <section>
      <h3>Message Specific Claims</h3>
    	<p>Message Tool JWTs MAY contain other <a>Claims</a>. The receiver of a Message
    		Tool JWT MUST ignore any claims it does not understand. Vendors MAY extend
    		the Message Tool JWT by adding additional Claims using a "Public Claim
        Name" as defined in Section 4.2 of the JWT in the [[!RFC7519]] specification.
        Vendors SHOULD only use domains that they own, and they MUST prefix these
        domains with "http://".
      </p>
    </section>
    <section>
      <h3>Message Signing</h3>
    	<p>Message Tool JWTs MUST be signed using the method described in [[!RFC7518]],
    		Message Tool JWTs MUST NOT use
        <code>none</code> as the <code>alg</code> value.
      </p>
      <p>Message Client JWTs SHOULD NOT use the JWS x5u, x5c, jku, or jwk Header
        Parameter fields. Instead, <a>Platforms</a> and Tools should communicate
        the keys to use for Message JWS Tokens during registration.</p>
    </section>
  </section>
  <section>
    <h2 id="h_key-management">Key Management</h2>
    <p>Some systems will require key management. In cases where systems use asymmetric
      keys, the <a>Issuer</a> of a JWT or access token signs it with its private
      key, and the recipient verifies the signature by using the Issuer's public
      key. The Issuer could be either a <a>Platform</a> or a <a>Consumer</a>. The system
      responsible for originating the message is the Issuer. The mechanisms by which
      keys are minted and distributed is outside the scope of this framework (see
      the <a href="#h_bestpractices">Best Practice Recommendations</a>). Therefore, there must be an
      out-of-band registration process during which access to the public keys is
      supplied. It should be noted that a Platform could be responsible for allocating
      key-sets to a Client: the integrity of the private key MUST be maintained by
      the accompanying distribution mechanism.</p>
    <section>
      <h3>RSA Key</h3>
      <p>Where systems use RSA Keys, they MUST use SHA-256 (RS256) as a minimum as defined
        in [[!RFC7518]]. Support for other algorithms is permitted but their use
        limits interoperability. Later versions of this framework MAY add OPTIONAL
        support for other algorithms.
      </p>
    </section>
    <section>
      <h3>JSON Web Key</h3>
      <p>When systems use JSON Web Keys (JWK) to represent the public key, such representations
        SHOULD conform to [[!RFC7517]]: parties exchanging keys represented this
        way MUST use this form during key exchanges.</p>
      <p>When using RSA keys, they MUST include the <em>n</em> (modulus) and
        <em>e</em> (exponent) as defined in [[!RFC7518]] (see the key set example
        in Section <a href="#h_key-set-url"></a>).</p>
    </section>
    <section>
      <h3 id="h_key-set-url">Key Set URL</h3>
      <p>When systems use Key Sets, they MUST provide a URL to the key set (the system
        responsible for supplying this URL must be identified in the corresponding
        IMS service specification). A JWK Set is a container of one or multiple public
        keys identified by their key identifier (
        <code>kid</code> key parameter). The [[!RFC7517]] defines JWK Sets.</p>
      <p>The supplier of the key set URL MUST use the <code>kid</code> parameter to
        identify the keys. Even when there is only one key in a key-set a
        <code>kid</code> MUST be supplied. Both a <a>Platform</a> and a
        <a>Consumer</a> could use key-sets.
      </p>
      <p>The <a>Issuer</a> of a JWT identifies the key a receiver uses to validate the
        JWT signature by using the <code>kid</code> JWT header <a>Claim</a>. The
        Issuer MUST NOT reuse the
        <code>kid</code> identifier to identify different public keys of the same
        type (
        <code>kty</code>), allowing the public key to be cached by the <a>Consumer</a>.
        The Issuer MAY issue a
        <code>cache-control: max-age</code> HTTP header on requests to retrieve a
        key set to signal how long the retriever may cache the key set before refreshing
        it.
      </p>
      <p>Here is an example of a JWK Set containing two RSA keys:</p>
      <pre><code>
{
    "keys": [{
        "e": "AQAB",
        "use": "sig",
        "alg": "RS256",
        "kty": "RSA",
        "n": "oNqXxxWuX7LlovO5reRNau5f96K_o3DJx-wK7lrjBmp0qKwNszbbp8MvfrlVs-oYXfj1rzqAeY6GJF5BETViDTT0i2fEz37J0HGAeTrO7Z5zI5Ure9Cb0lulLOZj1hF8piZzWW_z_set2NyhafoZ-IG1NSe61mqHu7mTjuHYST84igz-bPKhkJAVlmPPjHTO51hG9T_roVIkjXnvgqd2dCaJ0ExT2bR96jcyausbkdDNfPtJdfSCAWYXGQnt0PmIysOHPtCkyFqv5ez8KXT7Q4CAYd7nxwfWNOFRHyLAyF__cYEJlBEKGyJniSIPtkGBWrbXUQhKF6TEFa-RRRl8Dw==",
        "kid": "1516918956_0"
    }, {
        "e": "AQAB",
        "use": "sig",
        "alg": "RS256",
        "kty": "RSA",
        "n": "kMfHwTp2dIYybtvU-xzF2E3dRJBNBtNbb-d3-Rm6nRUraxnTwZ6Fr1YpFBd1pnWzLzdtMv7ofCd28nx-1mfYZ6qhqPWF1RpGe2vVOSTmcu-QpA9h-rouqRKlv3jvXPn623Z2U1Wml0EIxyIzD3WLu7NkWEKSIcBzeY1TctpO5FSU3EyyCX1UoIMuvYBP9tiZlc74yIZvky-qT8Ej3S8L0JqhvD583E_uGMoLowguOl2yYr9zhubiqOxT3VsxvpJCu04TWmvf4XX34IQRyAHcPJFQ2QiBfLWvWyc6iP3JJYJvyapwc5vVEismryXnngyBX8NXHZaarMi6g5kTQi8itw==",
        "kid": "1516918956_1"
    }]
}
</code></pre>
      <p>The details of the permitted parameters for RSA keys is supplied in Section
        6.3 of [[!RFC7518]]. This RFC should also be used for permitted parameters
        when using other JSON Web Algorithms.</p>
    </section>
    <section>
      <h3>Issuer Public Key Rotation</h3>
      <p>When the <a>Issuer</a> rotates its public key, the Issuer MUST add it to the
        JSON Key Set under a new <code>kid</code>. Other parties can then download
        a new version of the JSON Key Set. IMS recommends that Issuers doing key
        rotation preserve the previous public key in the JSON Key Set to allow an
        overlap.
      </p>
      <p>If the <a>Issuer</a> does not use the <code>kid</code> parameter to identify
        its key, other parties using the key SHOULD use the cache-control header
        to properly rotate their cached copies of the key.</p>
    </section>
  </section>
  <section id="h_bestpractices">
    <h2>Best Practice Recommendations</h2>
    <section>
      <h3>Access Token Management</h3>
      <section>
        <h4>Expires_In Values and Renewing the Access Token</h4>
        <p>The recommended value of the 'expires_in' attribute is 3600 i.e. one hour.
          This means that the validity of the access token expires one hour after
          the time it was issued. Client-credentails based OAuth 2 does NOT permit
          the use of access token refreshing. Therefore, once an access token has
          expired, a new access token MUST be requested. The same set of credentials
          MAY be reused when requesting a new access token. However, these credentials
          MAY also expire: if they expire then a request for an access token using
          these credentials MUST be refused. The use of expiry times for credentials
          is implementation dependent.</p>
      </section>
      <section>
        <h4 id="h_scope-naming-conventions">Scope Naming Conventions</h4>
        <p>When requesting an access token it is a requirement, for access to an IMS-compliant
          service, to identify the set of scopes for the access request. The set
          of scopes that are available as part of an IMS service are defined in the
          corresponding specification document. In this document is the naming convention
          that SHOULD be adopted for those scopes. This naming convention is based
          upon a broader set of guidelines created by IMS for all of its generated
          artifacts. The format for a scope is:</p>
        <pre><code>
https://purl.imsglobal.org/spec/[shortname]/[version]/scope/[scopeleaf].[action]
        </code></pre>
        <p>where:</p>
        <p><strong>[shortname]</strong> The abbreviated name of the service specification
          e.g. 'or' for OneRoster, 'lti' for LTI, etc.</p>
        <p><strong>[version]</strong> The version of the service specification e.g.
          'v1p0, 'v2p1', etc.
        </p>
        <p><strong>[scopeleaf]</strong> An appropriate term for the collection of endpoints
          being covered by the scope.</p>
        <p><strong>[action]</strong> A term that reflects that nature of the scope.
          The suggested values are:</p>
        <ul>
          <li>
            <p>'readonly' for a set of endpoints that permit read only using the 'GET'
              verb
            </p>
          </li>
          <li>
            <p>'createput' for a set of endpoints that permit creation using the 'PUT'
              verb
            </p>
          </li>
          <li>
            <p>'createpost' for a set of endpoints that permit creation using the 'POST'
              verb
            </p>
          </li>
          <li>
            <p>'update' for a set of endpoints that permit changing of an established
              resource
            </p>
          </li>
          <li>
            <p>'replace' for a set of endpoints that permit overwriting of an established
              resource
            </p>
          </li>
          <li>
            <p>'delete' for a set of endpoints that permit delete only</p>
          </li>
        	<li>
        		<p>'all' for access to all of endpoints supported for the version of the identified specification</p>
        	</li>
        </ul>
        <p>An example of some scopes that have already been defined by IMS are:</p>
        <pre><code>
https://purl.imsglobal.org/spec/or/v1p2/scope/gradebook.delete
        </code></pre>
        <p>which is used in OneRoster 1.2 to permit access to the endpoints that allow
          a gradebook resource to be deleted, and:</p>
        <pre><code>
https://purl.imsglobal.org/spec/rs/v1p0/scope/resource.readonly
        </code></pre>
        <p>which is used in LTI Resource Search 1.0 to permit access to the endpoints
          that allow access to the information about a set of resources.</p>
      </section>
      <section>
        <h4>Managing Scopes</h4>
        <p>IMS REQUIRES the use of scopes when obtaining an access token. The definition
          of the set of scopes for a service is contained within the corresponding
          IMS specification. Therefore, an authorization server MUST be made aware
          of these scopes. Either the credentials or the JWT claim set supplied when
          requesting the access token must be used to determine if the requesting
          client is permitted to request access depending on those scopes. Scope
          definitions are immutable and permanent.</p>
        <p>The way in which an authorization server obtains the information about the
          set of permitted scopes for a service is implementation dependent. An authorization
          server MUST support validation of scopes with respect to access token provision.
          A scope MUST NOT be allocated if it is not contained within the request
          for the access token.</p>
      </section>
    </section>
    <section>
      <h3>Key Distribution</h3>
      <p>The IMS approach to message signing is based upon the use of key-pairs (private
        and public key) by the two end-systems i.e. the <a>Platform</a> and the <a>Consumer</a>.
        Whereas distribution of public keys does not require a secure mechanism,
        the integrity of the private keys must not be compromised. A system SHOULD
        NOT use a single key pair to secure message signing for more than one system.
        Therefore, systems SHOULD be capable of obtaining and using many key pairs.</p>
      <p>Let the private and public key pair for a Platform be denoted by { P[X], P[K]
        } and the equivalent for a Consumer by { C[X], C[K] }. In the case of key-sets
        this becomes {{ P[X1], P[K1] }, ..., { P[Xm], P[Km] }} and {{ C[X1], C[K1]
        }, ..., { C[Xn], C[Kn] }} i.e the are 'm' key-pairs for the Platform and
        'n' key-pairs for the Consumer. Knowledge of the public keys, P[X1]..P[Km]
        and C[X1]..C[Kn] is unrestricted. Knowledge of the private keys SHOULD be
        as restricted as possble. For a Platform/Consumer pair the keys can be created
        by:
      </p>
      <p><strong>Platform only</strong>. The <a>Platform</a> creates both sets of key-pairs.
        The Platform is responsible for providing the <a>Consumer</a> with its keys
      	i.e. the Platform creates all of the keys and MUST securely give the Consumer
        the keys {{ C[X1], C[K1] }, ..., { C[Xn], C[Kn] }}. The Consumer must also
        be given the Platform's public keys i.e. { P[K1]..P[Km] }. The advantage
        of this approach is that the Consumer is not burdened with key creation and
        distribution. </p>
    	<p><strong>Consumer only</strong>. The <a>Consumer</a> creates both sets of key-pairs. The
      	Consumer is responsible for providing the <a>Platform</a> with the private
      	key i.e. the Consumer creates all of the keys and MUST securely give the Platfrom
        the keys {{ P[X1], P[K1] }, ..., { P[Xn], P[Km] }}. The Platform must also
        be given the Client's public keys i.e. { C[K1]..C[Kn] }. The disadvantage
        of this approach is that the Platform is dependent upon the Consumer creating
        sufficiently robust keys and for ensuring the integarity of these keys is
        not compromised.
      </p>
    	<p><strong>Platform and Consumer Independently</strong>. Each system create their
        on key pairs. Each system is responsible for making the other aware of the
        public keys. The advantage of this approach is that only the user of the
        private keys has knowledge of those keys. The disadvantage is that the
    		<a>Consumer</a> functionality is more complex.</p>
    	<p>In general, there will be many more Consumers than <a>Platforms</a>. It is important
        to minimise the implementation effort required to achieve the required message
        signing. This security framework is based upon security standards that have
        broad adoption. Key generation and distribution between Platforms and Consumers
        has not been defined. The ways in which key distribution is managed within
        a Consumer is dependent on:</p>
      <ul>
        <li>
        	<p>The business model used for the provision of access to the <a>Consumer</a>. The
        		distribution modes for the Consumer itself will indicate the best ways
            to manage the corresponding allocation of private keys and access to
            the relevant public keys;</p>
        </li>
        <li>
          <p>The key distribution models that become preferred by the <a>Platforms</a>.
            For educational technology this will be determined by the approaches
            required by learning management systems and/or student information systems.</p>
        </li>
      </ul>
      <p>New requirements and recommendations MAY be made in a later version of this
        framework, if, at some later date, there is a clarification, in the education
        technology marketplace, on the preferred mechanism for key distribution.</p>
    </section>
		<section>
			<h3>Handling Security Vulnerabilities</h3>
			<section>
				<h4>Symmetric vs. Asymmetric Keys with JWT</h4>
				<p><b>To be completed in the Final Release.</b></p>
			</section>
		</section>
  </section>
  <section class="appendix">
    <h2>Relevant Standards Summaries</h2>
    <section class="appendix">
      <h3>Relevant Request for Comments</h3>
      <section>
        <h4>RFC 2616 - HyperText Transfer Protocol</h4>
        <p>The Hypertext Transfer Protocol (HTTP/1.1) [[!RFC2616]] is an application-level
          protocol for distributed, collaborative, hypermedia information systems.
          It is a generic, stateless, protocol that can be used for many tasks beyond
          its use for hypertext, such as name servers and distributed object management
          systems, through extension of its request methods, error codes and headers.
          A feature of HTTP is the typing and negotiation of data representation,
          allowing systems to be built independently of the data being transferred.
          HTTP has been in use by the World-Wide Web global information initiative
          since 1990. This specification defines the protocol referred to as “HTTP/1.1”,
          and is an update to [[RFC2068]].</p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc2616.pdf">https://tools.ietf.org/pdf/rfc2616.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 2617 - HTTP Authentication: Basic and Digest Access Authentication</h4>
        <p>"HTTP/1.0", includes the specification for a Basic Access Authentication
          scheme [[RFC2617]]. This scheme is not considered to be a secure method
          of user authentication (unless used in conjunction with some external secure
          system such as SSL), as the user name and password are passed over the
          network as clear text.
        </p>
        <p>This document also provides the specification for HTTP’s authentication framework:
          the original Basic authentication scheme, and a scheme based on cryptographic
          hashes referred to as "Digest Access Authentication". It is, therefore,
          also intended to serve as a replacement for [[!RFC2069]]. Some optional
          elements specified by RFC 2069 have been removed from this specification
          due to problems found since its publication; other new elements have been
          added for compatibility--those new elements have been made optional, but
          are strongly recommended.
        </p>
        <p>Like Basic authentication, Digest Access authentication verifies that both
          parties to a communication know a shared secret (a password); unlike Basic
          authentication, this verification can be done without sending the password
          in the clear, which is Basic authentication’s biggest weakness. As with
          most other authentication protocols, the greatest sources of risks are
          usually found not in the core protocol itself but in policies and procedures
          surrounding its use.</p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc2617.pdf">https://tools.ietf.org/pdf/rfc2617.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 4949 - Internet Security Glossary Version 2</h4>
        <p>This Glossary provides definitions, abbreviations, and explanations of terminology
          for information system security [[!RFC4949]]. The 334 pages of entries
          offer recommendations to improve the comprehensibility of written material
          that is generated in the Internet Standards Process [[RFC2026]]. The recommendations
          follow the principles that such writing should follow these guidelines:</p>
        <p> a. Use the same term or definition whenever the same concept is mentioned.</p>
        <p> b. Use terms in their plainest, dictionary sense.</p>
        <p> c. Use terms that are already well-established in open publications.</p>
        <p> d. Avoid terms that either favor a particular vendor or favor a particular
          technology or mechanism over other, competing techniques that already exist
          or could be developed.
        </p>
        <p>This document is both a major revision and a major expansion of the original
          Internet Security Glossary [[RFC2828]]. This revised Glossary is an extensive
          reference that should help the Internet community to improve the clarity
          of documentation and discussion in an important area of Internet technology.
          However, readers should be aware of the following points:</p>
        <p>a. The recommendations and some particular interpretations in definitions
          are those of the author, not an official IETF position. The IETF has not
          taken a formal position either for or against recommendations made by this
          Glossary, and the use of [[!RFC2119]] language (e.g. SHOULD NOT) in the
          Glossary must be understood as unofficial. In other words, the usage rules,
          wording interpretations, and other recommendations that the Glossary offers
          are personal opinions of the Glossary’s author. Readers must judge for
          themselves whether or not to follow his recommendations, based on their
          own knowledge combined with the reasoning presented in the Glossary.</p>
        <p>b. The Glossary is rich in the history of early network security work, but
          it may be somewhat incomplete in describing recent security work, which
          has been developing rapidly.</p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc4949.pdf">https://tools.ietf.org/pdf/rfc4949.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 5246 - The Transport Layer Security Protocol Version 1.2</h4>
        <p>This document specifies Version 1.2 of the Transport Layer Security (TLS)
          protocol [[!RFC5246]]. The TLS protocol provides communications security
          over the Internet. The protocol allows client/server applications to communicate
          in a way that is designed to prevent eavesdropping, tampering, or message
          forgery.
        </p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc5246.pdf">https://tools.ietf.org/pdf/rfc5246.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 5849 - The OAuth 1.0 Protocol</h4>
        <p>OAuth provides a method for clients to access server resources on behalf
          of a resource owner (such as a different Client or an end user). It also
          provides a process for end-users to authorize third-party access to their
          server resources without sharing their credentials (typically, a username
          and password pair), using user-agent redirections.</p>
        <p>Use of OAuth 1.0 [[RFC5849]] within the context of IMS specifications is
          deprecated. The material in this document explains the security mechanisms
          that MUST be used to replace OAuth 1.0.</p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc5849.pdf">https://tools.ietf.org/pdf/rfc5849.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 6749 - The OAuth 2.0 Authorization Framework</h4>
        <p>The OAuth 2.0 authorization framework enables a third-party application to
          obtain limited access to an HTTP service, either on behalf of a resource
          owner by orchestrating an approval interaction between the resource owner
          and the HTTP service, or by allowing the third-party application to obtain
          access on its own behalf. This specification [[RFC6749]] replaces and obsoletes
          the OAuth 1.0 protocol described in [[!RFC5849]].</p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc6749.pdf">https://tools.ietf.org/pdf/rfc6749.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 6750 - The OAuth 2.0 Authorization Framework Bearer Token Usage</h4>
        <p>This specification describes how to use bearer tokens in HTTP requests to
          access OAuth 2.0 protected resources. Any party in possession of a bearer
          token (a "bearer") can use it to get access to the associated resources
          (without demonstrating possession of a cryptographic key). To prevent misuse,
          bearer tokens need to be protected from disclosure in storage and in transport
          [[RFC6750]].
        </p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc6750.pdf">https://tools.ietf.org/pdf/rfc6750.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 7515 - JSON Web Signature (JWS)</h4>
        <p>JSON Web Signature (JWS) represents content secured with digital signatures
          or Message Authentication Codes (MACs) using JSON-based data structures
          [[RFC7515]]. Cryptographic algorithms and identifiers for use with this
          specification are described in the separate JSON Web Algorithms (JWA) specification
          and an IANA registry defined by that specification. Related encryption
          capabilities are described in the separate JSON Web Encryption (JWE) specification.
        </p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc7515.pdf">https://tools.ietf.org/pdf/rfc7515.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 7517 - JSON Web Key</h4>
        <p>A JSON Web Key (JWK) is a JavaScript Object Notation (JSON) data structure
          that represents a cryptographic key. This specification also defines a
          JWK Set JSON data structure that represents a set of JWKs [[RFC7517]].
          Cryptographic algorithms and identifiers for use with this specification
          are described in the separate JSON Web Algorithms (JWA) specification and
          IANA registries established by that specification.
        </p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc7517.pdf">https://tools.ietf.org/pdf/rfc7517.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 7518 - JSON Web Algorithms</h4>
        <p>This specification registers cryptographic algorithms and identifiers to
          be used with the JSON Web Signature (JWS), JSON Web Encryption (JWE), and
          JSON Web Key (JWK) specifications [[RFC7518]]. It defines several IANA
          registries for these identifiers.
        </p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc7518.pdf">https://tools.ietf.org/pdf/rfc7518.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 7519 - JSON Web Token</h4>
        <p>A JWT is a compact, URL-safe means of representing <a>Claims</a> to be transferred
          between two parties. The Claims in a JWT are encoded as a JSON object that
          is used as the payload of a JSON Web Signature (JWS) structure or as the
          plaintext of a JSON Web Encryption (JWE) structure, enabling the Claims
          to be digitally signed or integrity protected with a Message Authentication
          Code (MAC) and/or encrypted [[RFC7519]].
        </p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc7519.pdf">https://tools.ietf.org/pdf/rfc7519.pdf</a>.</p>
      </section>
      <section>
        <h4>RFC 7523 - JSON Web Token Profile for OAuth 2.0 Client Authentication and Authorization Grants</h4>
        <p>This specification defines the use of a JWT bearer token as a means for requesting
          an OAuth 2.0 access token as well as for client authentication [[RFC7523]].
        </p>
        <p>This document is available at: <a href="https://tools.ietf.org/pdf/rfc7523.pdf">https://tools.ietf.org/pdf/rfc7523.pdf</a>.</p>
      </section>
    </section>
    <section>
      <h3>Relevant Other Standards</h3>
      <section>
        <h4>Open ID Connect Core</h4>
        <p>OpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol.
          It enables Clients to verify the identity of the end user based on the
          authentication performed by an Authorization Server, as well as to obtain
          basic profile information about the end user in an interoperable and REST-like
          manner. This specification defines the core OpenID Connect functionality:
          authentication built on top of OAuth 2.0 and the use of <a>Claims</a> to
          communicate information about the end user. It also describes the security
          and privacy considerations for using OpenID Connect [[!OPENID-CCORE]].
        </p>
        <p>This document is available at: <a href="http://openid.net/specs/openid-connect-core-1_0.html">http://openid.net/specs/openid-connect-core-1_0.html</a>.</p>
      </section>
      <section>
        <h4>OAuth 2.0 Form Post Response Mode</h4>
        <p>This specification defines the Form Post Response Mode. In this mode, Authorization
          Response parameters are encoded as HTML form values that are auto-submitted
          in the User Agent, and thus are transmitted via the HTTP POST method to
          the Client, with the result parameters being encoded in the body using
          the application/x-www-form-urlencoded format [[!OAUTH2-FPRM]].
        </p>
        <p>This document is available at: <a href="http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html">http://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html</a>.</p>
      </section>
    </section>
  </section>
  <section class="appendix informative" id="revisionhistory">
    <h2>Revision History</h2>
    <section>
      <h3>Version History</h3>
      <table title="Revision History" summary="Publication history and revision details for this specification.">
        <thead>
          <tr>
            <th>Version No.</th>
            <th>Release Date</th>
            <th>Comments</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>IMS Candidate Final</td>
            <td>27th March 2018</td>
            <td>The first Candidate Final release.</td>
          </tr>
          <tr>
            <td>IMS Candidate Final</td>
            <td>25th July, 2018</td>
            <td>The second Candidate Final release.</td>
          </tr>
        </tbody>
      </table>
    </section>
    <section>
      <h3>Changes in this Version</h3>
      	<p>The changes made for this 25th July, 2018 Candidate Final update are:</p>
    	<ul>
    		<li>Conversion of the document format to make use of the IMS profiled version of the W3C Respec tool;</li>
      		<li>Completion of the Abstract;</li>
    		<li>Clarification on the definition and usage of the terms Client, Consumer and Platform;</li>
    		<li>Clarification on the overall Security Architecture (Section 2);</li>
      		<li>Removal of reference to the use of JSON Web Encryption (JWE) including removal of a summary of the corresponding RFC 2716;</li>
    		<li>Inclusion of support for OAuth 2.0 Authorization Grant as an alterative to the use of Client Credentials Grant for 'Securing Web Services' (Section 4).</li>
      </ul>

    </section>
  </section>
  <!-- /revision history -->

</body>

</html>
